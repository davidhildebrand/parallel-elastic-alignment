/**
 * Call
 *
 * xvfb-run -a ./ImageJ-linux64 -Ddir=<project directory> -Dfile=<import file>  -- --no-splash import-and-align.bsh
 *
 * on the cluster with absolute paths, e.g.
 *
 * ${HOME}/bin/xvfb-run -a ${HOME}/packages/Fiji.app/fiji-linux64 \
 *   -Xms10g -Xmx10g -Ddir=${HOME}/AL-FIB-Z0712-12/0-99 \
 *   -Dfile=${HOME}/AL-FIB-Z0712-12/0-99/import.txt  -- --no-splash \
 *   ${HOME}/AL-FIB-Z0712-12/AL-FIB-Z0712-12/import-and-align.bsh
 * 
 * @author Stephan Saalfeld <saalfeld@mpi-cbg.de>
 */

import ini.trakem2.ControlWindow;
import ini.trakem2.Project;
import ini.trakem2.display.Layer;
import ini.trakem2.display.Patch;
import ini.trakem2.utils.Filter;
/* import ini.trakem2.utils.Montage; */
import ini.trakem2.imaging.filters.NormalizeLocalContrast;
import ini.trakem2.imaging.filters.IFilter;
import ij.ImagePlus;
import java.lang.Runtime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import mpicbg.trakem2.align.Align;
import mpicbg.trakem2.align.AlignTask;
import mpicbg.trakem2.align.ElasticLayerAlignment;
import mpicbg.trakem2.align.RegularizedAffineLayerAlignment;


try {
	runtime = Runtime.getRuntime();
	System.out.println( runtime.availableProcessors() + " cores available but not necessarily allocated for multi-threading" );
	
	dir = System.getProperty("dir");
	file = System.getProperty("file");
	
	ControlWindow.setGUIEnabled(false);
	project = Project.newFSProject("blank", null, dir, false);
	loader = project.getLoader();
	loader.setMipMapsRegeneration(false); /* prevent mipmap generation */
	layerset = project.getRootLayerSet();
	layerset.setSnapshotsMode(1);
	

	/* add a reference layer (pointless gymnastik) */
	layer = new Layer(project, 0, 1, layerset);
	layerset.add(layer);
	layer.recreateBuckets();

	
	/* import images */
	task = loader.importImages(
			layerset.getLayer(0),	// the first layer
			file,			// the absolute path to the text file with absolute image paths
			" ",			// the column separator  <path> <x> <y> <section index>
			1.0,			// section thickness, defaults to 1
			1.0,			// calibration, defaults to 1
			false,			// whether to homogenize contrast, avoid
			1.0f,			// scaling factor, default to 1
			0);			// border width

	
	/* wait until all images have been imported */
	task.join();


	/* apply filters */
	System.out.println( "Applying local contrast filters..." );
	for (p : layerset.getDisplayables(Patch.class))
		p.appendFilters(new IFilter[]{new NormalizeLocalContrast(1000, 1000, 3.0f, true, true)});
	System.out.println( "... finished." );
	System.out.println( "Generating mipmaps..." );
	loader.setMipMapsRegeneration(true); /* start mipmap generation */
	

	/* wait until all mipmaps are generated */
	futures = new ArrayList();
	for (p : layerset.getDisplayables(Patch.class))
		futures.add(p.updateMipMaps());
	for (f : futures)
		f.get();
	System.out.println( "... finished." );


	/* delete reference layer if it was not part of the import range */
	l0 = layerset.getLayer(0);
	if (l0.getDisplayables(Patch.class).size() == 0)
		layerset.remove(l0);
	

	/* save the project */
		project.saveAs(dir + "/project.xml", false);
	

	/* prepare intra-section alignment */
	System.out.println( "Locking template image in each layer..." );
	nonEmptyLayers = new ArrayList();
	layerRangeMontage = layerset.getLayers();
	for (l : layerRangeMontage) {
		numPatches = l.getDisplayables(Patch.class).size();
		if (numPatches > 1) {
			for (p : l.getDisplayables(Patch.class)) {
				Pattern pattern = Pattern.compile("mo_.*");
				Matcher matcher = pattern.matcher(p.getTitle());
				if (matcher.matches()) {
					p.setLocked(true);
				}
			}
			nonEmptyLayers.add(l);
		}
	}
	System.out.println( "... finished." );


	/* intra-section montage alignment */
	System.out.println( "Intra-section montage alignment starting..." );
	paramMontage = new Align.ParamOptimize();
	paramMontage.sift.initialSigma 		= 1.6f;
	paramMontage.sift.steps 		= 3;
	paramMontage.sift.minOctaveSize 	= 300;
	paramMontage.sift.maxOctaveSize 	= 1500;
	paramMontage.sift.fdSize 		= 4;
	paramMontage.sift.fdBins 		= 8;
	paramMontage.rod 			= 0.92f;
	/*
	paramMontage.clearCache 		= true;
	paramMontage.maxNumThreadsSift 		= 6; //runtime.availableProcessors();
	*/

	paramMontage.maxEpsilon 		= 100.0f;
	paramMontage.minInlierRatio 		= 0.00f;
	paramMontage.minNumInliers 		= 20;
        /*  ModelIndex 0 = "Translation", 1 = "Rigid", 2 = "Similarity", 3 = "Montage" */
	paramMontage.expectedModelIndex 	= 3; /* affine */
	paramMontage.rejectIdentity 		= false;
	paramMontage.identityTolerance 		= 0.0f;
	/*
	paramMontage.multipleHypotheses 	= false;
	paramMontage.maxNumNeighbors 		= 10;
	paramMontage.maxNumFailures 		= 10;
	paramMontage.maxNumThreads 		= 6; //runtime.availableProcessors();
	*/
	
	paramMontage.desiredModelIndex 		= 3; /* affine */
	paramMontage.correspondenceWeight	= 1.0f;
	paramMontage.regularize 		= false;
	/*
	paramMontage.regularizerIndex 		= 1;
	*/
	paramMontage.maxIterations	 	= 2000;
	paramMontage.maxPlateauwidth	 	= 200;
	paramMontage.filterOutliers		= false;
	paramMontage.meanFactor 		= 3.0f;
	tilesAreInPlace				= false;
	largestGraphOnly 			= false;
	hideDisconnectedTiles 			= false;
	deleteDisconnectedTiles 		= false;
	/*
	paramMontage.visualize 			= false;
	*/ 

	AlignTask.montageLayers(paramMontage,
				nonEmptyLayers, 
				tilesAreInPlace, 
				largestGraphOnly, 
				hideDisconnectedTiles, 
				deleteDisconnectedTiles);
	/* AlignTask.montageLayers(paramMontage, layerset.getLayers(), False, False, False, False); */
	System.out.println( "... finished." );

	/* unlock after intra-section alignment */
	System.out.println( "Unlocking template image in each layer..." );
	for (l : nonEmptyLayers) {
		for (p : l.getDisplayables(Patch.class)) {
			Pattern pattern = Pattern.compile("mo_.*");
			Matcher matcher = pattern.matcher(p.getTitle());
			if (matcher.matches()) {
				p.setLocked(false);
			}
		}
	}
	System.out.println( "... finished." );


	/* prepare inter-section alignment */
	layerRange = layerset.getLayers();
	fixedLayers = new HashSet();
	emptyLayers = new HashSet();
	
	filter = new Filter() {
		public boolean accept(Patch patch) {
			return patch.isVisible();
			}
		};
	

	/* affine alignment */
	/* determined in collaboration with S Saalfeld 140609 */
	System.out.println( "Inter-section affine alignment starting..." );

	paramAffine = new RegularizedAffineLayerAlignment.Param();
	
	paramAffine.ppm.sift.initialSigma 	= 1.6f;
	paramAffine.ppm.sift.steps 		= 3;
	paramAffine.ppm.sift.minOctaveSize 	= 400;
	paramAffine.ppm.sift.maxOctaveSize 	= 1024;
	paramAffine.ppm.sift.fdSize 		= 8;
	paramAffine.ppm.sift.fdBins 		= 8;
	paramAffine.ppm.rod 			= 0.92f;
	paramAffine.ppm.clearCache 		= true;
	paramAffine.ppm.maxNumThreadsSift 	= 6; //runtime.availableProcessors();
	
	paramAffine.maxEpsilon 			= 1000.0f;
	paramAffine.minInlierRatio 		= 0.00f;
	paramAffine.minNumInliers 		= 12;
        /*  ModelIndex 0 = "Translation", 1 = "Rigid", 2 = "Similarity", 3 = "Affine" */
	paramAffine.expectedModelIndex 		= 3; /* affine */
	paramAffine.multipleHypotheses 		= false;
	paramAffine.rejectIdentity 		= false;
	paramAffine.identityTolerance 		= 0.0f;
	paramAffine.maxNumNeighbors 		= 10;
	paramAffine.maxNumFailures 		= 5;
	paramAffine.maxNumThreads 		= 6; //runtime.availableProcessors();
	
	paramAffine.desiredModelIndex 		= 3; /* affine */
	paramAffine.regularize 			= true;
	paramAffine.maxIterationsOptimize 	= 5000;
	paramAffine.maxPlateauwidthOptimize 	= 200;
	paramAffine.regularizerIndex 		= 1;
	paramAffine.visualize 			= false;


	/* first affine regularized by 0.10 rigid */
	paramAffine.lambda 			= 0.1f;
	new RegularizedAffineLayerAlignment().exec(
			paramAffine,
			layerRange,	
			fixedLayers,
			emptyLayers,
			layerset.get2DBounds(),
			false,
			false,
			filter);
	System.out.println( "... 0.10 rigid regularized finished." );

	
	/* second affine regularized by 0.01 rigid */
	paramAffine.lambda 			= 0.01f;
	layerset.setMinimumDimensions();
	
	new RegularizedAffineLayerAlignment().exec(
			paramAffine,
			layerRange,	
			fixedLayers,
			emptyLayers,
			layerset.get2DBounds(),
			false,
			false,
			filter);
	System.out.println( "... 0.01 rigid regularized finished." );
	
	layerset.setMinimumDimensions();

		
	/* save the project */
	project.saveAs(dir + "/project.xml", true);


	/* elastic alignment */
	System.out.println( "Inter-section elastic alignment starting..." );

	paramElastic = new ElasticLayerAlignment.Param();
	
	paramElastic.layerScale 		= 0.25f;
	paramElastic.searchRadius 		= 60;
	paramElastic.blockRadius 		= 600;
	paramElastic.resolutionSpringMesh 	= 32;
	
	paramElastic.minR 			= 0.6f;
	paramElastic.maxCurvatureR 		= 10.0f;
	paramElastic.rodR 			= 0.98f;
	
	paramElastic.useLocalSmoothnessFilter 	= true;
	paramElastic.localModelIndex 		= 3; /* affine */
	paramElastic.localRegionSigma 		= 800.0f;
	paramElastic.maxLocalEpsilon 		= 20.0f;
	paramElastic.maxLocalTrust 		= 3.0f;
	
	paramElastic.isAligned 			= true;
	paramElastic.maxNumNeighbors 		= 10;
	paramElastic.maxNumFailures		= 5;
	paramElastic.maxNumThreads 		= 6;
	
	paramElastic.desiredModelIndex 		= 1; /* rigid */
	paramElastic.maxIterationsOptimize 	= 1000;
	paramElastic.maxPlateauwidthOptimize 	= 200;

	paramElastic.stiffnessSpringMesh 	= 0.10f;
	paramElastic.maxStretchSpringMesh 	= 2000.0f;
	paramElastic.maxIterationsSpringMesh 	= 5000;
	paramElastic.maxPlateauwidthSpringMesh 	= 1000;
	paramElastic.dampSpringMesh 		= 0.9f;
	paramElastic.useLegacyOptimizer 	= true;

	new ElasticLayerAlignment().exec(
		paramElastic,
		project,
		layerRange,
		fixedLayers,
		emptyLayers,
		layerset.get2DBounds(),
		false,
		false,
		filter);
	System.out.println( "... finished." );


	/* DGCH remove filters */
	System.out.println( "Removing local contrast filters..." );
	for (p : layerset.getDisplayables(Patch.class))
		p.setFilters(null);
	System.out.println( "... finished." );

	/* wait until all mipmaps are generated */
	futures = new ArrayList();
	for (p : layerset.getDisplayables(Patch.class))
		futures.add(p.updateMipMaps());
	for (f : futures)
		f.get();
	layerset.setMinimumDimensions();
		

	/* save the project */
	project.saveAs(dir + "/project.xml", true);
}
catch (e) {
	e.printStackTrace();
}

/* shutdown */
runtime.exit(0);

